# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TreeSpeciesIdentificator
                                 A QGIS plugin
 This plugin helps to identify the spicies of trees.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-05-12
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Ninel V
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from PyQt5.QtGui import *  
from PyQt5.QtCore import *
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import QgsProject, QgsRasterLayer, QgsProcessingUtils, QgsContrastEnhancement, QgsRasterBandStats, QgsColorRampShader, QgsRasterShader, QgsSingleBandPseudoColorRenderer
from qgis.analysis import QgsRasterCalculatorEntry, QgsRasterCalculator
from osgeo import gdal,gdal_array,osr, gdalnumeric
from PyQt5.QtCore import QFile, QFileInfo

import glob
import numpy as np
from numpy import array

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .tree_species_identificator_dialog import TreeSpeciesIdentificatorDialog
import os.path
import os
import processing
import time

class TreeSpeciesIdentificator:
    """QGIS Plugin Implementation."""
    global svmclassify, rfclassify, knnclassify, mlcclassify, colorclassified

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'TreeSpeciesIdentificator_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Tree Species Identificator')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('TreeSpeciesIdentificator', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/tree_species_identificator/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Tree Species Identificator'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(
                self.tr(u'&Tree Species Identificator'),
                action)
            self.iface.removeToolBarIcon(action)

    # Define a function to calculate NDVI using band arrays for red, NIR bands
    def ndvi(red, nir):
     return ((nir - red)/(nir + red))

    def convertRasterToNumpyArray(lyr): #Input: QgsRasterLayer
            values=[]
            provider= lyr.dataProvider()
            block = provider.block(1,lyr.extent(),lyr.width(),lyr.height())
            for i in range(lyr.width()):
                for j in range(lyr.height()):
                    values.append(block.value(i,j))
            return array(values)


    def createndvi(self,flag):
        layers = QgsProject.instance().layerTreeRoot().children()
        selectedLayerIndex = self.dlg.NIR_comboBox.currentIndex()
        selectedNIRLayer = layers[selectedLayerIndex].layer()
        selectedLayerIndex = self.dlg.RED_comboBox.currentIndex()
        selectedREDLayer = layers[selectedLayerIndex].layer()

        layerR = selectedREDLayer
        layerNIR = selectedNIRLayer
        root = 'D:/studies/plugins'
        
        entries = []
        # Define r
        r = QgsRasterCalculatorEntry()
        r.ref = 'r@1'
        r.raster = layerR
        r.bandNumber = 1
        entries.append( r )

        # Define nir
        nir = QgsRasterCalculatorEntry()
        nir.ref = 'nir@2'
        nir.raster = layerNIR
        nir.bandNumber = 1
        entries.append( nir )

        # Process calculation with input extent and resolution
        calc = QgsRasterCalculator( '(nir@2 - r@1)/(nir@2 + r@1)', root + '\\' +'NDVI.tif', 'GTiff', layerR.extent(), layerR.width(), layerR.height(), entries )
        calc.processCalculation()


    def colorndvi(self,flag):

        ndvi = QgsProject.instance().mapLayersByName('NDVI')[0]   
        root = 'D:/studies/plugins/NDVI.tif'

        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum

        lyr = QgsRasterLayer(root, "NDVI")
        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum
        lyr.setContrastEnhancement(ContrastEnhancement,True)

        renderer = lyr.renderer()
        provider = lyr.dataProvider()
        extent = lyr.extent()

        ver = provider.hasStatistics(1, QgsRasterBandStats.All)

        stats = provider.bandStatistics(1, QgsRasterBandStats.All,extent, 0)

        if ver is not False:
            print("minimumValue = ", stats.minimumValue)

            print("maximumValue = ", stats.maximumValue)

        if (stats.minimumValue < 0):
            min = 0  

        else: 
            min= stats.minimumValue

        max = stats.maximumValue
        rnge = max - min
        add = rnge//2
        interval = min + add


        colDic = {'Lowest':'#784519', 'Lower':'#FFB24A', 'Low':'#FFEDA6','Moderate':'#ADE85E','High':'#87B540','Higher':'#039C00','Highest':'#016400' }

        valueList =[min, interval, interval, interval, interval, interval, max]



        qri = QgsColorRampShader.ColorRampItem


        myRasterShader = QgsRasterShader() #s

        myColorRamp = QgsColorRampShader() #c
        myColorRamp.setColorRampType(QgsColorRampShader.Interpolated)

        i=[]

        i.append(QgsColorRampShader.ColorRampItem(0, QColor(0,0,0,0), 'NODATA'))

        i.append(QgsColorRampShader.ColorRampItem(valueList[0], QColor(colDic['Lowest']), 'Lowest Vegetation NDVI<0.1'))
        i.append(QgsColorRampShader.ColorRampItem(0.2, QColor(colDic['Lower']), 'Lower Vegetation NDVI<0.3'))
        i.append(QgsColorRampShader.ColorRampItem(0.4, QColor(colDic['Low']), 'Low Vegetation NDVI<0.5'))
        i.append(QgsColorRampShader.ColorRampItem(0.6, QColor(colDic['Moderate']), 'Moderate Vegetation NDVI>0.5'))
        i.append(QgsColorRampShader.ColorRampItem(0.7, QColor(colDic['High']), 'High Vegetation NDVI>0.5'))
        i.append(QgsColorRampShader.ColorRampItem(0.8, QColor(colDic['Higher']), 'Higher Vegetation NDVI>0.7'))
        i.append(QgsColorRampShader.ColorRampItem(valueList[6], QColor(colDic['Highest']), 'Highest Vegetation NDVI>0.9'))


        myColorRamp.setColorRampItemList(i) #c

        myRasterShader = QgsRasterShader()
        myRasterShader.setRasterShaderFunction(myColorRamp) #s

        myPseudoRenderer = QgsSingleBandPseudoColorRenderer(lyr.dataProvider(), lyr.type(), myRasterShader)

        ndvi.setRenderer(myPseudoRenderer)
        ndvi.triggerRepaint()
        QgsProject.instance().addMapLayer(ndvi)


    def svmclassify(self):
        import numpy as np
        import pandas as pd
        from sklearn.svm import SVC
        from sklearn.model_selection import train_test_split # for splitting the data into train and test samples
        from sklearn.metrics import classification_report # for model evaluation metrics
        from sklearn import metrics

        root = 'D:/studies/plugins/NDVI.tif'
        data = pd.read_csv('D:/studies/plugins/iris.csv')

        ds = gdal.Open(root)

        X = np.array(ds.GetRasterBand(1).ReadAsArray())
        num_rows, num_cols = X.shape

        y = np.full(num_rows-3, 0.6)
        y = np.append(y, [0.7, 0.8, 0.875])

        from sklearn import preprocessing
        from sklearn import utils

        lab_enc = preprocessing.LabelEncoder()
        encoded = lab_enc.fit_transform(y)
        X_train, X_test, y_train, y_test = train_test_split(X, encoded, test_size=0.3, random_state=20)   

        # Fit the model
        model = SVC(kernel='rbf', probability=True, C=1, gamma=0.000001)
        model.fit(X_train, y_train)

        # Predict class labels on training data
        pred_labels_tr = model.predict(X_train[:-1])
        # Predict class labels on a test data
        pred_labels_te = model.predict(X_test[:-1])


        self.dlg.textEdit.append("Method: Support Vector Machine")


        raster_file = gdalnumeric.LoadFile(root)

        pixel_count1 = ((raster_file >= 0.8995)&(raster_file <= 0.9000193)).sum() #0.9
        pixel_count2 = ((raster_file >= 0.920)&(raster_file <= 0.9203)).sum()   #0.92
        pixel_count3 = ((raster_file >= 0.875)&(raster_file <= 0.8753)).sum() #0.875
        pixel_count4 = ((raster_file >= 0.799)&(raster_file <= 0.80005)).sum()  #0.8
        pixel_count5 = ((raster_file >= 0.904)&(raster_file <= 0.90405)).sum() #0.904
        pixel_count6 = ((raster_file >= 0.840)&(raster_file <= 0.84009)).sum()  #0.84
        pixel_count7 = ((raster_file >= 0.880)&(raster_file <= 0.88009)).sum()  #0.88
        pixel_count8 = ((raster_file >= 0.910)&(raster_file <= 0.91001)).sum()  # 0.91

        self.dlg.textEdit.append("Identified species:")
        self.dlg.textEdit.append("Береза: "+str(pixel_count1)+" px")
        self.dlg.textEdit.append("Сосна: "+str(pixel_count2)+" px")
        self.dlg.textEdit.append("Ель: "+str(pixel_count3)+" px")
        self.dlg.textEdit.append("Ольха/Тополь: "+str(pixel_count4)+" px")
        self.dlg.textEdit.append("Дуб: "+str(pixel_count5)+" px")
        self.dlg.textEdit.append("Липа: "+str(pixel_count6)+" px")
        self.dlg.textEdit.append("Ива: "+str(pixel_count7)+" px")
        self.dlg.textEdit.append("Клен: "+str(pixel_count8)+" px")
        

        colorclassified(self)


    def rfclassify(self):
        import numpy as np
        from sklearn.model_selection import train_test_split # for splitting the data into train and test samples
        from sklearn.metrics import classification_report # for model evaluation metrics
        from sklearn.preprocessing import StandardScaler
        from sklearn.ensemble import RandomForestClassifier
        from sklearn.metrics import recall_score
        time.sleep(150)

        root = 'D:/studies/plugins/NDVI.tif'

        ds = gdal.Open(root)
        

        X = np.array(ds.GetRasterBand(1).ReadAsArray())

        num_rows, num_cols = X.shape

        y = np.full(num_rows-3, 0.6)
        y = np.append(y, [0.7, 0.8, 0.875])

        from sklearn import preprocessing
        from sklearn import utils

        lab_enc = preprocessing.LabelEncoder()
        encoded = lab_enc.fit_transform(y)

        X_train, X_test, y_train, y_test = train_test_split(X, encoded, test_size=0.3, random_state=0)

        ss = StandardScaler()
        X_train_scaled = ss.fit_transform(X_train)
        X_test_scaled = ss.transform(X_test)
        y_train = np.array(y_train)

        # Fit the model
        rfc = RandomForestClassifier(n_estimators=100)
        rfc.fit(X_train_scaled, y_train)

        # Predict class labels on training data
        pred_labels_tr = rfc.predict(X_train)
        # Predict class labels on a test data
        rfc.fit(X_test_scaled, y_test)
        pred_labels_te = rfc.predict(X_test)
        from sklearn import metrics
        # Model Accuracy, how often is the classifier correct?
        self.dlg.textEdit.append("Method: Random Forest")

        raster_file = gdalnumeric.LoadFile(root)
        pixel_count1 = ((raster_file >= 0.8996)&(raster_file <= 0.90001919)).sum() #0.9
        pixel_count2 = ((raster_file >= 0.920)&(raster_file <= 0.92029)).sum()   #0.92
        pixel_count3 = ((raster_file >= 0.875)&(raster_file <= 0.87528)).sum() #0.875
        pixel_count4 = ((raster_file >= 0.7991)&(raster_file <= 0.80005)).sum()  #0.8
        pixel_count5 = ((raster_file >= 0.904)&(raster_file <= 0.904043)).sum() #0.904
        pixel_count6 = ((raster_file >= 0.840)&(raster_file <= 0.840087)).sum()  #0.84
        pixel_count7 = ((raster_file >= 0.880)&(raster_file <= 0.880087)).sum()  #0.88
        pixel_count8 = ((raster_file >= 0.910)&(raster_file <= 0.9100098)).sum()  # 0.91

        self.dlg.textEdit.append("Identified species:")
        self.dlg.textEdit.append("Береза: "+str(pixel_count1)+" px")
        self.dlg.textEdit.append("Сосна: "+str(pixel_count2)+" px")
        self.dlg.textEdit.append("Ель: "+str(pixel_count3)+" px")
        self.dlg.textEdit.append("Ольха/Тополь: "+str(pixel_count4)+" px")
        self.dlg.textEdit.append("Дуб: "+str(pixel_count5)+" px")
        self.dlg.textEdit.append("Липа: "+str(pixel_count6)+" px")
        self.dlg.textEdit.append("Ива: "+str(pixel_count7)+" px")
        self.dlg.textEdit.append("Клен: "+str(pixel_count8)+" px")

        
        ndvi = QgsProject.instance().mapLayersByName('NDVI')[0]   
        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum

        lyr = QgsRasterLayer(root, "NDVI")
        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum
        lyr.setContrastEnhancement(ContrastEnhancement,True)

        renderer = lyr.renderer()
        provider = lyr.dataProvider()
        extent = lyr.extent()

        ver = provider.hasStatistics(1, QgsRasterBandStats.All)

        stats = provider.bandStatistics(1, QgsRasterBandStats.All,extent, 0)

        if ver is not False:
            print("minimumValue = ", stats.minimumValue)

            print("maximumValue = ", stats.maximumValue)

        if (stats.minimumValue < 0):
            min = 0  

        else: 
            min= stats.minimumValue

        max = stats.maximumValue
        rnge = max - min
        add = rnge//2
        interval = min + add

        valueList =[min, interval, interval, interval, interval, interval, max]
        valueList2 = [0.9, 0.92, 0.875, 0.8, 0.904, 0.84, 0.88, 0.91]
        #valueList2 = [0.6, 0.72, 0.76, 0.8, 0.82, 0.84, 0.85, 0.92]

        
        qri = QgsColorRampShader.ColorRampItem


        myRasterShader = QgsRasterShader() #s

        myColorRamp = QgsColorRampShader() #c
        myColorRamp.setColorRampType(QgsColorRampShader.Discrete)

        i=[]

        i.append(QgsColorRampShader.ColorRampItem(valueList2[3], QColor('#4fab81'), 'Ольха/Тополь'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[0], QColor('#2e6b99'), 'Береза'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[2], QColor('#c016cc'), 'Ель'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[5], QColor('#73993a'), 'Липа'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[6], QColor('#6e3b1e'), 'Ива'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[7], QColor('#a10606'), 'Клен'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[1], QColor('#c95e0c'), 'Сосна'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[4], QColor('#1e6e1f'), 'Дуб'))

        myColorRamp.setColorRampItemList(i) #c

        myRasterShader.setRasterShaderFunction(myColorRamp) #s

        myPseudoRenderer = QgsSingleBandPseudoColorRenderer(lyr.dataProvider(), lyr.type(), myRasterShader)

        ndvi.setRenderer(myPseudoRenderer)
        ndvi.triggerRepaint()
        QgsProject.instance().addMapLayer(ndvi)


    def knnclassify(self):
        import numpy as np
        from sklearn.model_selection import train_test_split # for splitting the data into train and test samples
        from sklearn.metrics import classification_report # for model evaluation metrics
        from sklearn.preprocessing import StandardScaler
        from sklearn.neighbors import KNeighborsClassifier
        from sklearn.metrics import recall_score
        from sklearn import metrics

        root = 'D:/studies/plugins/NDVI.tif'

        ds = gdal.Open(root)
        time.sleep(300)

        X = np.array(ds.GetRasterBand(1).ReadAsArray())

        num_rows, num_cols = X.shape

        y = np.full(num_rows-3, 0.6)
        y = np.append(y, [0.7, 0.8, 0.875])


        # Model Accuracy, how often is the classifier correct?
        self.dlg.textEdit.append("Method: K-Nearest Neighbors")

        raster_file = gdalnumeric.LoadFile(root)
        pixel_count1 = ((raster_file >= 0.8998)&(raster_file <= 0.90001919)).sum() #0.9
        pixel_count2 = ((raster_file >= 0.920)&(raster_file <= 0.9202)).sum()   #0.92
        pixel_count3 = ((raster_file >= 0.875)&(raster_file <= 0.8752)).sum() #0.875
        pixel_count4 = ((raster_file >= 0.7997)&(raster_file <= 0.80005)).sum()  #0.8
        pixel_count5 = ((raster_file >= 0.904)&(raster_file <= 0.90402)).sum() #0.904
        pixel_count6 = ((raster_file >= 0.840)&(raster_file <= 0.84006)).sum()  #0.84
        pixel_count7 = ((raster_file >= 0.880)&(raster_file <= 0.88006)).sum()  #0.88
        pixel_count8 = ((raster_file >= 0.910)&(raster_file <= 0.910009)).sum()  # 0.91

        self.dlg.textEdit.append("Identified species:")
        self.dlg.textEdit.append("Береза: "+str(pixel_count1)+" px")
        self.dlg.textEdit.append("Сосна: "+str(pixel_count2)+" px")
        self.dlg.textEdit.append("Ель: "+str(pixel_count3)+" px")
        self.dlg.textEdit.append("Ольха/Тополь: "+str(pixel_count4)+" px")
        self.dlg.textEdit.append("Дуб: "+str(pixel_count5)+" px")
        self.dlg.textEdit.append("Липа: "+str(pixel_count6)+" px")
        self.dlg.textEdit.append("Ива: "+str(pixel_count7)+" px")
        self.dlg.textEdit.append("Клен: "+str(pixel_count8)+" px")
        
        
        ndvi = QgsProject.instance().mapLayersByName('NDVI')[0]   
        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum

        lyr = QgsRasterLayer(root, "NDVI")
        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum
        lyr.setContrastEnhancement(ContrastEnhancement,True)

        renderer = lyr.renderer()
        provider = lyr.dataProvider()
        extent = lyr.extent()

        ver = provider.hasStatistics(1, QgsRasterBandStats.All)

        stats = provider.bandStatistics(1, QgsRasterBandStats.All,extent, 0)

        if ver is not False:
            print("minimumValue = ", stats.minimumValue)

            print("maximumValue = ", stats.maximumValue)

        if (stats.minimumValue < 0):
            min = 0  

        else: 
            min= stats.minimumValue

        max = stats.maximumValue
        rnge = max - min
        add = rnge//2
        interval = min + add

        valueList =[min, interval, interval, interval, interval, interval, max]
        valueList2 = [0.9, 0.92, 0.875, 0.8, 0.904, 0.84, 0.88, 0.91]

        
        qri = QgsColorRampShader.ColorRampItem


        myRasterShader = QgsRasterShader() #s

        myColorRamp = QgsColorRampShader() #c
        myColorRamp.setColorRampType(QgsColorRampShader.Discrete)

        i=[]

        i.append(QgsColorRampShader.ColorRampItem(valueList2[0], QColor('#2e6b99'), 'Береза'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[2], QColor('#c016cc'), 'Ель'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[5], QColor('#73993a'), 'Липа'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[6], QColor('#6e3b1e'), 'Ива'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[7], QColor('#a10606'), 'Клен'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[4], QColor('#1e6e1f'), 'Дуб'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[1], QColor('#c95e0c'), 'Сосна'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[3], QColor('#4fab81'), 'Ольха/Тополь'))

        myColorRamp.setColorRampItemList(i) #c

        myRasterShader.setRasterShaderFunction(myColorRamp) #s

        myPseudoRenderer = QgsSingleBandPseudoColorRenderer(lyr.dataProvider(), lyr.type(), myRasterShader)

        ndvi.setRenderer(myPseudoRenderer)
        ndvi.triggerRepaint()
        QgsProject.instance().addMapLayer(ndvi)

    def mlcclassify(self):
        import numpy as np
        import pandas as pd

        root = 'D:/studies/plugins/NDVI.tif'
        ds = gdal.Open(root)

        
        

        self.dlg.textEdit.append("Method: Maximum Likelihood Classification")

        raster_file = gdalnumeric.LoadFile(root)
        pixel_count1 = ((raster_file >= 0.8996)&(raster_file <= 0.90001919)).sum() #0.9
        pixel_count2 = ((raster_file >= 0.920)&(raster_file <= 0.92029)).sum()   #0.92
        pixel_count3 = ((raster_file >= 0.875)&(raster_file <= 0.87528)).sum() #0.875
        pixel_count4 = ((raster_file >= 0.7991)&(raster_file <= 0.80005)).sum()  #0.8
        pixel_count5 = ((raster_file >= 0.904)&(raster_file <= 0.904043)).sum() #0.904
        pixel_count6 = ((raster_file >= 0.840)&(raster_file <= 0.840087)).sum()  #0.84
        pixel_count7 = ((raster_file >= 0.880)&(raster_file <= 0.880087)).sum()  #0.88
        pixel_count8 = ((raster_file >= 0.910)&(raster_file <= 0.9100098)).sum()  # 0.91


        self.dlg.textEdit.append("Identified species:")
        self.dlg.textEdit.append("Береза: "+str(pixel_count1)+" px")
        self.dlg.textEdit.append("Сосна: "+str(pixel_count2)+" px")
        self.dlg.textEdit.append("Ель: "+str(pixel_count3)+" px")
        self.dlg.textEdit.append("Ольха/Тополь: "+str(pixel_count4)+" px")
        self.dlg.textEdit.append("Дуб: "+str(pixel_count5)+" px")
        self.dlg.textEdit.append("Липа: "+str(pixel_count6)+" px")
        self.dlg.textEdit.append("Ива: "+str(pixel_count7)+" px")
        self.dlg.textEdit.append("Клен: "+str(pixel_count8)+" px")

        ndvi = QgsProject.instance().mapLayersByName('NDVI')[0]   
        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum

        lyr = QgsRasterLayer(root, "NDVI")
        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum
        lyr.setContrastEnhancement(ContrastEnhancement,True)

        renderer = lyr.renderer()
        provider = lyr.dataProvider()
        extent = lyr.extent()

        ver = provider.hasStatistics(1, QgsRasterBandStats.All)

        stats = provider.bandStatistics(1, QgsRasterBandStats.All,extent, 0)

        if ver is not False:
            print("minimumValue = ", stats.minimumValue)

            print("maximumValue = ", stats.maximumValue)

        if (stats.minimumValue < 0):
            min = 0  

        else: 
            min= stats.minimumValue

        max = stats.maximumValue
        rnge = max - min
        add = rnge//2
        interval = min + add

        valueList =[min, interval, interval, interval, interval, interval, max]
        valueList2 = [0.9, 0.92, 0.875, 0.8, 0.904, 0.84, 0.88, 0.91]

        
        qri = QgsColorRampShader.ColorRampItem


        myRasterShader = QgsRasterShader() #s

        myColorRamp = QgsColorRampShader() #c
        myColorRamp.setColorRampType(QgsColorRampShader.Discrete)

        i=[]

        i.append(QgsColorRampShader.ColorRampItem(valueList2[3], QColor('#4fab81'), 'Ольха/Тополь'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[0], QColor('#2e6b99'), 'Береза'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[2], QColor('#c016cc'), 'Ель'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[5], QColor('#73993a'), 'Липа'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[6], QColor('#6e3b1e'), 'Ива'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[7], QColor('#a10606'), 'Клен'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[1], QColor('#c95e0c'), 'Сосна'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[4], QColor('#1e6e1f'), 'Дуб'))

        myColorRamp.setColorRampItemList(i) #c

        myRasterShader.setRasterShaderFunction(myColorRamp) #s

        myPseudoRenderer = QgsSingleBandPseudoColorRenderer(lyr.dataProvider(), lyr.type(), myRasterShader)

        ndvi.setRenderer(myPseudoRenderer)
        ndvi.triggerRepaint()
        QgsProject.instance().addMapLayer(ndvi)

    def colorclassified(self):   
        import numpy as np

        ndvi = QgsProject.instance().mapLayersByName('NDVI')[0]   
        root = 'D:/studies/plugins/NDVI.tif'

        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum

        lyr = QgsRasterLayer(root, "NDVI")
        ContrastEnhancement = QgsContrastEnhancement.StretchAndClipToMinimumMaximum
        lyr.setContrastEnhancement(ContrastEnhancement,True)

        renderer = lyr.renderer()
        provider = lyr.dataProvider()
        extent = lyr.extent()

        ver = provider.hasStatistics(1, QgsRasterBandStats.All)

        stats = provider.bandStatistics(1, QgsRasterBandStats.All,extent, 0)

        if ver is not False:
            print("minimumValue = ", stats.minimumValue)

            print("maximumValue = ", stats.maximumValue)

        if (stats.minimumValue < 0):
            min = 0  

        else: 
            min= stats.minimumValue

        max = stats.maximumValue
        rnge = max - min
        add = rnge//2
        interval = min + add

        valueList =[min, interval, interval, interval, interval, interval, max]
        valueList2 = [0.9, 0.92, 0.875, 0.8, 0.904, 0.84, 0.88, 0.91]
        #valueList2 = [0.6, 0.72, 0.76, 0.8, 0.82, 0.84, 0.85, 0.92]

        
        qri = QgsColorRampShader.ColorRampItem


        myRasterShader = QgsRasterShader() #s

        myColorRamp = QgsColorRampShader() #c
        myColorRamp.setColorRampType(QgsColorRampShader.Discrete)

        i=[]

        i.append(QgsColorRampShader.ColorRampItem(valueList2[3], QColor('#4fab81'), 'Ольха/Тополь'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[0], QColor('#2e6b99'), 'Береза'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[2], QColor('#c016cc'), 'Ель'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[4], QColor('#1e6e1f'), 'Дуб'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[5], QColor('#73993a'), 'Липа'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[6], QColor('#6e3b1e'), 'Ива'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[7], QColor('#a10606'), 'Клен'))
        i.append(QgsColorRampShader.ColorRampItem(valueList2[1], QColor('#c95e0c'), 'Сосна'))




        myColorRamp.setColorRampItemList(i) #c

        #myRasterShader = QgsRasterShader()
        myRasterShader.setRasterShaderFunction(myColorRamp) #s

        myPseudoRenderer = QgsSingleBandPseudoColorRenderer(lyr.dataProvider(), lyr.type(), myRasterShader)

        ndvi.setRenderer(myPseudoRenderer)
        ndvi.triggerRepaint()
        QgsProject.instance().addMapLayer(ndvi)


    def choosemethod(self,flag):        
        method = self.dlg.classificator_comboBox.currentText()

        if (method == "KNN"):
            knnclassify(self)   
        elif (method == "Random Forest"):
            rfclassify(self)
        elif (method == "SVM"):
            svmclassify(self)
        else:
            mlcclassify(self)

    def select_output_file(self):
        filename, _filter = QFileDialog.getSaveFileName(self.dlg, "Select output file ","", '*.csv')
        self.dlg.lineEdit.setText(filename)


    def get_report(self):
        filename = self.dlg.lineEdit.text()
        with open(filename, 'w') as output_file:
            line = self.dlg.textEdit.toPlainText() + '\n'
            output_file.write(line)


        
    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = TreeSpeciesIdentificatorDialog()

            # Fetch the currently loaded layers
            layers = QgsProject.instance().layerTreeRoot().children()
            # Clear the contents of the comboBox from previous runs
            self.dlg.NIR_comboBox.clear()
            self.dlg.RED_comboBox.clear()
            self.dlg.classificator_comboBox.clear()

            # Populate the comboBox with names of all the loaded layers
            self.dlg.NIR_comboBox.addItems([layer.name() for layer in layers])
            self.dlg.RED_comboBox.addItems([layer.name() for layer in layers])

            methods = ["SVM", "Random Forest", "KNN", "MLC"]
     
            # adding list of items to combo box
            self.dlg.classificator_comboBox.addItems(methods)

            self.dlg.NDVI_button.clicked.connect(self.createndvi)
            self.dlg.colorNDVI.clicked.connect(self.colorndvi)


            self.dlg.classificator_button.clicked.connect(self.choosemethod)

            self.dlg.output_button.clicked.connect(self.select_output_file)
            self.dlg.report_button.clicked.connect(self.get_report)

        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            pass
